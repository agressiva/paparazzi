.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Ivy 3pm"
.TH Ivy 3pm "2006-10-17" "perl v5.8.4" "User Contributed Perl Documentation"
.SH "NAME"
Ivy \- Perl extension for implementing a software bus
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Ivy;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Ivy perl module implements a software bus that provides easy
communication between applications. Messages are broadcast as \s-1ASCII\s0 strings
over a network defined by a list of domains and a port.
Messages are received if they match a regular expressions and if your application
is on the same network as remote ones.
Before receive or send message you must call 'init', and 'new' class methods,
followed by 'start' method.
When you quit your application don't forget to call 'exit' class methods.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "\fBinit\fR" 2
.IX Item "init"
.Vb 2
\& Ivy\->init(...);
\& Ivy::init(...);
.Ve
.Sp
Allows one to define global parameters which may be used as default ones
at object creation time.
.Sp
Parameters are :
.RS 2
.IP "\fB\-loopMode => '\s-1TK\s0'|'\s-1LOCAL\s0'\fR" 4
.IX Item "-loopMode => 'TK'|'LOCAL'"
Mode of events loop among \s-1TK\s0 or \s-1LOCAL\s0. According to this mode, you must
use Ivy\->mainLoop or \fITk::MainLoop\fR\|(3)
.IP "\fB\-appName => 'your app ivy name'\fR" 4
.IX Item "-appName => 'your app ivy name'"
Name of your application used to identify on ivy bus.
.IP "\fB\-ivyBus => 'domain 1,...,domain n:port number'\fR" 4
.IX Item "-ivyBus => 'domain 1,...,domain n:port number'"
A list of domains (may be empty), followed by a port number where to broadcast messages.
If the domain list is empty (i.e. parameter is ':port number'), broadcast will be done
on localhost (i.e. '127:port number'). Default is the value of the environment variable
\&\s-1IVYBUS\s0 and if it is not defined the default is 127:2010.
.Sp
Since V4.12, it is possible to use multicast (ie. with a domain between 224.0.0.0 and 239.255.255.255). You must be aware than when multicast is used, udp broadcast (defined in the \fB\-ivyBus\fR paramter) are skipped. You should also probably avoid using the 244.x.x.x domain often used for networking management.
.IP "\fB\-messWhenReady => 'your message when ready'\fR" 4
.IX Item "-messWhenReady => 'your message when ready'"
Synchronisation message sent when application is ready to receive and send
messages.
.ie n .IP "\fB\-onDieFunc => [\e&yourdiefunc, \fB@parameters\fB]\fR" 4
.el .IP "\fB\-onDieFunc => [\e&yourdiefunc, \f(CB@parameters\fB]\fR" 4
.IX Item "-onDieFunc => [&yourdiefunc, @parameters]"
.PD 0
.ie n .IP "\fB\-onDieFunc => [$an_object, \e&a_method, \fB@parameters\fB]\fR" 4
.el .IP "\fB\-onDieFunc => [$an_object, \e&a_method, \f(CB@parameters\fB]\fR" 4
.IX Item "-onDieFunc => [$an_object, &a_method, @parameters]"
.PD
A callback or method to call when your application receive a suicide request.
Do not call \fIexit()\fR in the callback, Ivy will do it for you.
.Sp
The prototype of your callback must be as follows:
.Sp
.Vb 4
\& sub MyCallback {
\&   my @parameters = @_;
\&   ...
\& }
.Ve
.Sp
The prototype of your method must be as follows:
.Sp
.Vb 4
\& sub MyMethod {
\&   my ($self, @parameters) = @_;
\&   ...
\& }
.Ve
.IP "\fB\-filterRegexp => ['subject 1', ..., 'subject n']\fR" 4
.IX Item "-filterRegexp => ['subject 1', ..., 'subject n']"
Optimize communication using this option. Regexps
which don't match these subjects are removed.
.IP "\fBExample:\fR" 4
.IX Item "Example:"
.Vb 4
\&  Ivy\->init(\-loopMode     => 'TK',
\&            \-appName      => 'MyWonderfulApp',
\&            \-onDieFunc    => [\e&restorecontext] ,
\&            \-filterRegexp => ['MyWonderfulApp', 'ClockStart', 'ClockStop']);
.Ve
.RE
.RS 2
.RE
.IP "\fBnew\fR" 2
.IX Item "new"
.Vb 2
\& Ivy::new(...);
\& Ivy\->new(...);
.Ve
.Sp
Check parameters, and create an Ivy bus object. You must call
Ivy\->init before creating a bus.
.Sp
Parameters are :
.RS 2
.IP "\fB\-appName => 'your application name'\fR" 4
.IX Item "-appName => 'your application name'"
Name of your application used to identify it with other applications
connected on the same bus.
.IP "\fB\-ivyBus => 'domain 1,...,domain n:port number'\fR" 4
.IX Item "-ivyBus => 'domain 1,...,domain n:port number'"
A list of domains, followed by port number where to broadcast messages.
Default is 127:2010
.IP "\fB\-messWhenReady => 'your message when ready'\fR" 4
.IX Item "-messWhenReady => 'your message when ready'"
Synchronisation message sent when your application is ready to receive and send
messages.
.ie n .IP "\fB\-onDieFunc => [\e&yourdiefunc, \fB@parameters\fB]\fR" 4
.el .IP "\fB\-onDieFunc => [\e&yourdiefunc, \f(CB@parameters\fB]\fR" 4
.IX Item "-onDieFunc => [&yourdiefunc, @parameters]"
.PD 0
.ie n .IP "\fB\-onDieFunc => [$an_object, \e&a_method, \fB@parameters\fB]\fR" 4
.el .IP "\fB\-onDieFunc => [$an_object, \e&a_method, \f(CB@parameters\fB]\fR" 4
.IX Item "-onDieFunc => [$an_object, &a_method, @parameters]"
.PD
A callback or method called when your application receives a suicide request.
\&\s-1DO\s0 \s-1NOT\s0 \s-1CALL\s0 \fIexit()\fR in the callback, Ivy will do it for you.
The prototype of your callback must be as follows:
.Sp
.Vb 4
\& sub MyCallback {
\&   my @parameters = @_;
\&   ...
\& }
.Ve
.Sp
The prototype of your method must be as follows:
.Sp
.Vb 4
\& sub MyMethod {
\&   my ($self, @parameters) = @_;
\&   ...
\& }
.Ve
.IP "\fB\-filterRegexp => ['subject 1', ..., 'subject n']\fR" 4
.IX Item "-filterRegexp => ['subject 1', ..., 'subject n']"
Optimize communication using this option. Regexps which don't match these subjects are removed.
.IP "\fB\-neededApp => ['app 1', ..., 'app n']\fR" 4
.IX Item "-neededApp => ['app 1', ..., 'app n']"
A list of applications that your application needs present on the bus
before running.
.IP "\fB\-statusFunc => sub {}\fR" 4
.IX Item "-statusFunc => sub {}"
A callback which is called every time an agent C connects on the bus,
disconnects from the bus, subscribes to a regexp, or unsubscribes to a
regexp. When the agent A is stopping, this function is also called
inside the agent A for every other agents C on the bus, as they are
disconnecting. The first 3 parameters are a reference to an array of
connected agents Ci, a reference to an array of not connected agents
(according to the \*(L"\-neededApp\*(R" argument of the new method / function),
a reference to a hash table of connected agents Ci (giving the number
of each agent). These 3 parameters are maintained for upwards
compatibility but should no more be used, since the following four
parameters are much easier to use: the name of an appearing /
disapearing or subscribing / filtered / unsubscribing agent C, its status either
\&\*(L"new\*(R" or \*(L"died\*(R" or \*(L"subscribing\*(R" or \*(L"unsubscribing\*(R", and the hostname
where this agent C is running / dying \s-1OR\s0 the subscribed / unsubscribed
regexp. If the hostname of this agent C is not known, it will be
replaced by its \s-1IP\s0 address.
.Sp
Your callback could be:
.Sp
.Vb 3
\& sub MyCallback {
\&   my ($ref_array_present, $ref_array_absent, $ref_hash_present,
\&       $appname, $status, $host, $regexp) = @_;
.Ve
.Sp
.Vb 1
\&   # $status is either new or died
.Ve
.Sp
.Vb 22
\&   my %present=%$ref_hash_present;
\&   foreach my $remoteapp (keys %present) {
\&     if ($present{$remoteapp} > 1) {
\&       print "n apps $remoteapp are presents on bus\en";
\&     }
\&   }
\&   if ($status eq "new") {
\&     print "$appname connected from $host\en";
\&   }
\&   elsif ($status eq "died") {
\&     print "$appname disconnected from $host\en";
\&   }
\&   elsif ($status eq "subscribing") {
\&        print "$appname subscribes to $regexp\en";
\&   }
\&   elsif ($status eq "filtered") {
\&        print "$appname subscribes to FILTERED $regexp check \-filterRegexp option\en";
\&   }
\&   elsif ($status eq "unsubscribing") {
\&        print "$appname unsubscribed to $regexp\en";
\&   }
\& }
.Ve
.IP "\fB\-blockOnSlowAgent => 0 or 1\fR" 4
.IX Item "-blockOnSlowAgent => 0 or 1"
Behavior when the bus is being congested due to an ivy agent which
doesn't read messages sufficiently quickly. In blocking mode the local
app will block on a send, so it won't be interactive until the send
return, and it will at his turn don't read his pending message,
leading to a global sluggishness of the entire ivy bus.  In non
blocking mode the messages are stocked until they could be sent, so
the problem is the uncontrolled memory consumption.
.IP "\fB\-slowAgentFunc=> \e&congestionFunc \fR" 4
.IX Item "-slowAgentFunc=> &congestionFunc "
.Vb 5
\& A callback which is called every time a congestion event occurs. A
\& congestion event is emitted each time an agent is being congested,
\& or, after being congested is able to read his messages again.  The
\& parameters are the name of the app, his address (hostname+port
\& number), and the state, 1 for congested, 0 for able to read.
.Ve
.Sp
.Vb 1
\& Your callback could be:
.Ve
.Sp
sub congestionFunc ($$$)
{
  my ($name, \f(CW$addr\fR, \f(CW$state\fR) = \f(CW@_\fR;
  printf (\*(L"$name [$addr] \f(CW%s\fR\en\*(R", \f(CW$state\fR ? \*(L"\s-1CONGESTION\s0\*(R" : \*(L"\s-1OK\s0\*(R");
}
.IP "\fBExample:\fR" 4
.IX Item "Example:"
.Vb 6
\& Ivy\->new(\-ivyBus => '156,157:2204',
\&          \-onDieFunc => [\e&restorecontext],
\&          \-neededApp => ["DataServer", "HMI"],
\&          \-slowAgentFunc=> \e&congestionFunc,
\&          \-blockOnSlowAgent => 1,
\&          \-statusFunc => \e&MyCallback);
.Ve
.RE
.RS 2
.RE
.IP "\fBmainLoop\fR" 2
.IX Item "mainLoop"
.Vb 3
\& Ivy\->mainLoop;
\& Ivy::mainLoop;
\& $ivyobj\->mainLoop;
.Ve
.Sp
.Vb 1
\& main events loop, call local mainloop or Tk::MainLoop according so specified mode
.Ve
.IP "\fBstop\fR" 2
.IX Item "stop"
.Vb 2
\& $ivyobj\->stop;
\& Ivy::stop;
.Ve
.Sp
To stop the Ivy main loop.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.IP "\fBstart\fR" 2
.IX Item "start"
.Vb 2
\& $ivyobj\->start;
\& Ivy::start;
.Ve
.Sp
You must call this after you are ready to communicate through an Ivy bus
and before you really communicate. The method returns the \f(CW$ivyobj\fR.
.IP "\fBsendMsgs\fR" 2
.IX Item "sendMsgs"
.Vb 2
\& $ivyobj\->sendMsgs(@messages);
\& Ivy::sendMsgs(@messages);
.Ve
.Sp
Send a list of messages. A message should not contain a '\en' or it will not be delivered.
.Sp
.Vb 2
\& Example :
\&   $ivyobj\->sendMsgs("Hello", "Don't Bother", "Y2K is behind us");
.Ve
.IP "\fBsendAppNameMsgs\fR" 2
.IX Item "sendAppNameMsgs"
.Vb 2
\& $ivyobj\->sendAppNameMsgs(@messages);
\& Ivy::sendAppNameMsgs(@messages);
.Ve
.Sp
Send a list of messages preceded by your application's name.  A message should not contain a '\en' or it will not be delivered.
.Sp
.Vb 3
\& Example :
\&   $ivyobj\->sendMsgs("Hello World");
\&   # it will send "$appName Hello World" over the Ivy bus
.Ve
.IP "\fBbindRegexp\fR" 2
.IX Item "bindRegexp"
.Vb 2
\& $ivyobject\->bindRegexp($regexp, [\e&callback, @cb_parameters]);
\& Ivy::bindRegexp($regexp, [\e&callback, @cb_parameters]);
.Ve
.Sp
.Vb 2
\& $ivyobject\->bindRegexp($regexp, [$an_obj, \e&method, @cb_parameters]);
\& Ivy::bindRegexp($regexp, [$an_obj, \e&method, @cb_parameters]);
.Ve
.Sp
This allows you to bind a regular expression to a
callback or method. The callback or method will be called for every
message that matches the regexp (case insensitive).
See \fIperlre\fR\|(1) to find how to write regexps.
Use the bracketing construct ( ... ) so that your callback is
called with the captured bits of text as parameters.
To unbind callback(s) associated to a regexp use bindRegexp with only
one argument, the regexp. Note that doing the same binding more than
once will induce multiple call of the same callback (this is usually a bug).
.Sp
there is a special syntax for specifying numeric interval, in this case
the interval is locally transformed in a pcre regexp.
syntax is (?Imin#max[fi]). min and max are the bounds,
by default the regexp match decimal number, but if max bound is
followed by 'i', the regexp match only integers ex : (?I\-10#20), (?I20#25i)
Note that due to the regexp generator limitation (which will perhaps be raised eventually)
the bounds are always integer.
.Sp
Return value : regexpId
.Sp
.Vb 3
\& Example :
\&   $ivyobject\->bindRegexp("\ew+ (\ed+)", [\e&callback, @cb_parameters]);
\&   $ivyobject\->bindRegexp("\ew+ ((?I\-10#20i))", [\e&callback, @cb_parameters]);
.Ve
.Sp
.Vb 2
\&   # Your callback will be called with one more parameter which will be
\&   # the name of appli which send the message
.Ve
.Sp
.Vb 6
\&   # Your callback and method must be like:
\&   sub callback {
\&     my ($sendername, @cb_parameters,
\&         @matched_regexps_in_brackets) = @_;
\&     ...
\&   }
.Ve
.Sp
.Vb 5
\&   sub method {
\&     my ($self, $sendername, @cb_parameters,
\&                @matched_regexps_in_brackets) = @_;
\&     ...
\&   }
.Ve
.Sp
.Vb 2
\&   # to unbind:
\&   $ivyobject\->bindRegexp("\ew+ (\ed+)");
.Ve
.IP "\fBbindRegexpOneShot\fR" 2
.IX Item "bindRegexpOneShot"
.Vb 2
\& $ivyobject\->bindRegexpOneShot($regexp, [\e&callback, @cb_parameters]);
\& Ivy::bindRegexpOneShot($regexp, [\e&callback, @cb_parameters]);
.Ve
.Sp
.Vb 3
\& bindRegexpOneShot behavior is similar at bindRegexp one, except that
\& the callback is called once, it is similar as a  bindRegexp with an unbind in the callback
\& but is simpler to write.
.Ve
.IP "\fBchangeRegexp\fR" 2
.IX Item "changeRegexp"
.Vb 4
\& $regexpId = $ivyobject\->bindRegexp("initialRegexp", [\e&callback, @cb_parameters]);
\& $ivyobject\->changeRegexp($regexpId, "newRegexp");
\&  or
\& Ivy::changeRegexp($regexpId, "newRegexp");
.Ve
.Sp
This allow you to change the regexp of a previously made bindRegexp, the callback
will remain the same. This is equivalent to unbinding current regexp and binding the new regexp,
but in this last case the 2 op are not done in atomic manner, and you can miss a message
or receive it twice.
.IP "\fBsendDirectMsgs\fR" 2
.IX Item "sendDirectMsgs"
.Vb 2
\& $ivyobj\->sendDirectMsgs($to, $id, @msgs);
\& Ivy::sendDirectMsgs($to, $id, @msgs);
.Ve
.Sp
Send a message a message to appli \f(CW$to\fR. This appli must have done a bindDirect before to accept this message. regexp matching is not used with direct Messages.  A message should not contain a '\en' or it will not be delivered.
.IP "\fBbindDirect\fR" 2
.IX Item "bindDirect"
.Vb 2
\& $ivyobj\->bindDirect($regexp, $id, [\e&callback, @cb_parameters]);
\& Ivy::bindDirect($id, [\e&callback, @cb_parameters]);
.Ve
.Sp
The callback will be called with both the \f(CW@msgs\fR and the \f(CW@cb_parameters\fR.
.Sp
.Vb 2
\& Example :
\&   $ivyobject\->bindDirectMessage("id1", [\e&callback, @cb_parameters]);
.Ve
.Sp
.Vb 5
\&   # Your callback and method must be like:
\&   sub cb {
\&     my (@cb_parameters, @msgs) = @_;
\&     ...
\&   }
.Ve
.Sp
.Vb 4
\&   sub method {
\&     my ($self, @cb_parameters, @msgs) = @_;
\&     ...
\&   }
.Ve
.IP "\fBsendDieTo\fR" 2
.IX Item "sendDieTo"
.Vb 2
\& $ivyobj\->sendDieTo($to);
\& Ivy::sendDieTo($to);
.Ve
.Sp
Send a suicide to the application named \f(CW$to\fR.
.IP "\fBping\fR" 2
.IX Item "ping"
.Vb 2
\& $ivyobj\->ping($to, $timeout);
\& Ivy::ping($to, $timeout);
.Ve
.Sp
Send a ping message and wait until timeout to receive a pong.
.IP "\fBafter\fR" 2
.IX Item "after"
.Vb 2
\& $after_id = $ivyobj\->after($timeAfter, \e@callbacks_list);
\& $after_id = Ivy::after($timeAfter, \e@callbacks_list);
.Ve
.Sp
Call a list of callbacks after \f(CW$timeAfter\fR milliseconds. To be used only in conjonction with the '\s-1LOCAL\s0' Mainloop (see the Init method). When using the \s-1TK\s0 mainloop, you must use the Tk::after method.
.IP "\fBrepeat\fR" 2
.IX Item "repeat"
.Vb 2
\& $repeat_id = $ivyobj\->repeat($timeAfter, \e@callbacks_list);
\& $repeat_id = Ivy:repeat($timeAfter, \e@callbacks_list);
.Ve
.Sp
Have a list of callbacks repeatedly called every \f(CW$timeAfter\fR milliseconds. To be used only in conjonction with the '\s-1LOCAL\s0' Mainloop (see the Init method). When using the \s-1TK\s0 mainloop, you must use the Tk::repeat method.
.IP "\fBafterCancel\fR" 2
.IX Item "afterCancel"
.Vb 2
\& $ivyobj\->afterCancel($after_or_repeat_id);
\& Ivy::afterCancel($after_or_repeat_id);
.Ve
.Sp
Cancel an after callback call. To be used only in conjonction with the '\s-1LOCAL\s0' Mainloop (see the Init method). When using the \s-1TK\s0 mainloop, you must use the Tk::afterCancel method.
.IP "\fBafterResetTimer\fR" 2
.IX Item "afterResetTimer"
.Vb 2
\& $ivyobj\->afterResetTimer($after_id);
\& Ivy::afterResetTimer($after_id);
.Ve
.Sp
Reset a timer if this timer has not yet been triggered. To be used only in conjonction with the '\s-1LOCAL\s0' Mainloop (see the Init method).
.IP "\fBfileEvent\fR" 2
.IX Item "fileEvent"
.Vb 2
\& $ivyobj\->fileEvent($fd, $cb);
\& Ivy::fileEvent($fd, $cb);
.Ve
.Sp
Add a fileEvent handler (or remove any handler associated to \f(CW$fd\fR if \f(CW$cb\fR paramter is omitted).
The callback \f(CW$cb\fR will get the filehandle \f(CW$fd\fR as parameter.  To be used only in conjonction with the '\s-1LOCAL\s0' Mainloop (see the Init method). When using the \s-1TK\s0 mainloop, you must use the Tk::fileevent method.
.IP "\fB\s-1DESTROY\s0\fR" 2
.IX Item "DESTROY"
.Vb 1
\& $ivyobj\->DESTROY;
.Ve
.Sp
Destroy the \f(CW$ivyobj\fR object. No other method should be applied to the reference of this deleted object. This method should not be used directly.
.SH "BUGS"
.IX Header "BUGS"
The stop method does not work!
.PP
In the statusFunc, an agent is identified by its name which is not garantted as unique
.PP
A message to be sent should not contain '\en' char, because the '\en' is the message separator. Ivy.pm will detect and skip such messages.
.PP
No other known bugs at this time. If you find one, please report them to the authors.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIperlre\fR\|(1), \fIivyprobe.pl\fR\|(1)
.SH "AUTHORS Alexandre Bustico <alexandre.bustico@cena.fr> Stéphane Chatty <chatty@intuilab.com> Hervé Damiano <herve.damiano@aviation\-civile.gouv.fr> Christophe Mertz <mertz@intuilab.com>"
.IX Header "AUTHORS Alexandre Bustico <alexandre.bustico@cena.fr> Stéphane Chatty <chatty@intuilab.com> Hervé Damiano <herve.damiano@aviation-civile.gouv.fr> Christophe Mertz <mertz@intuilab.com>"
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
\&\s-1CENA\s0 (C) 1997\-2006
.SH "HISTORY"
.IX Header "HISTORY"
